// CPU Module Complete Structure - All Types, Functions, and Relationships
// Based on actual source code audit from docs/architecture/codebase-inventory.md

digraph CPU_Module {
    // Graph settings
    rankdir=TB;
    compound=true;
    splines=ortho;
    nodesep=0.6;
    ranksep=1.0;

    // Node defaults
    node [shape=box, style=filled, fillcolor=lightgray, fontname="Arial", fontsize=10];
    edge [fontname="Arial", fontsize=9];

    // ========== CPU STATE (src/cpu/State.zig) ==========
    subgraph cluster_cpu_state {
        label="CpuState (src/cpu/State.zig)\n6502 Registers + Execution State Machine";
        style=filled;
        fillcolor=lightblue;

        subgraph cluster_registers {
            label="6502 Registers";
            style=dashed;

            cpu_regs [label="Registers:\la: u8 = 0        // Accumulator\lx: u8 = 0        // X index\ly: u8 = 0        // Y index\lsp: u8 = 0xFD    // Stack pointer\lpc: u16 = 0      // Program counter\lp: StatusFlags = .{} // CZIDB-VN\l", fillcolor=lightcyan, shape=box];
        }

        subgraph cluster_exec_state {
            label="Execution State Machine";
            style=dashed;

            exec_state [label="ExecutionState enum (17 states):\n.fetch_opcode\n.fetch_operand_low\n.fetch_operand_high\n.calc_address_low\n.calc_address_high\n.dummy_read\n.dummy_write\n.execute\n.write_result\n.push_high\n.push_low\n.pull\n.interrupt_sequence\n.branch_taken\n.branch_page_cross", fillcolor=wheat, shape=record];

            exec_fields [label="Microstep Fields:\ninstruction_cycle: u8 = 0\nstate: ExecutionState = .fetch_opcode\nopcode: u8 = 0\noperand_low: u8 = 0\noperand_high: u8 = 0\neffective_address: u16 = 0\naddress_mode: AddressingMode = .implied\npage_crossed: bool = false\ndata_bus: u8 = 0\ntemp_value: u8 = 0\ntemp_address: u16 = 0", fillcolor=lightyellow, shape=record];
        }

        subgraph cluster_interrupt_state {
            label="Interrupt State";
            style=dashed;

            interrupt_fields [label="Interrupt Tracking:\npending_interrupt: InterruptType = .none\nnmi_line: bool = false\nnmi_edge_detected: bool = false\nirq_line: bool = false\nhalted: bool = false", fillcolor=lightcoral, shape=record];

            interrupt_type [label="InterruptType enum:\n.none\n.nmi\n.irq\n.reset\n.brk", fillcolor=lightcoral, shape=record];
        }

        subgraph cluster_cpu_functions {
            label="Public Functions";
            style=dashed;

            cpu_note [label="NOTE: No methods on CpuState\nAll operations via Logic module\nPure data structure", fillcolor=lightyellow, shape=note];
        }
    }

    // ========== CPU CORE STATE (src/cpu/State.zig) ==========
    subgraph cluster_cpu_core {
        label="CpuCoreState (src/cpu/State.zig)\nPure CPU State - 6502 Registers Only";
        style=filled;
        fillcolor=palegreen;

        core_state [label="CpuCoreState struct:\la: u8 = 0\lx: u8 = 0\ly: u8 = 0\lsp: u8 = 0xFD\lpc: u16 = 0\lp: StatusFlags = .{}\leffective_address: u16 = 0\l", fillcolor=palegreen, shape=box];

        core_note [label="Purpose:\nImmutable state for pure opcode functions\nNO execution context\nNO bus access\nNO side effects\nSize: ~15 bytes (optimal for copying)", fillcolor=palegreen, shape=note];
    }

    // ========== OPCODE RESULT (src/cpu/State.zig) ==========
    subgraph cluster_opcode_result {
        label="OpcodeResult (src/cpu/State.zig)\nDelta Structure for Opcode Returns";
        style=filled;
        fillcolor=wheat;

        opcode_result [label="OpcodeResult struct:\na: ?u8 = null\nx: ?u8 = null\ny: ?u8 = null\nsp: ?u8 = null\npc: ?u16 = null\nflags: ?StatusFlags = null\nbus_write: ?BusWrite = null\npush: ?u8 = null\npull: bool = false\nhalt: bool = false", fillcolor=wheat, shape=record];

        result_buswrite [label="BusWrite struct:\naddress: u16\nvalue: u8", fillcolor=wheat, shape=record];

        result_note [label="Design:\nAll fields optional (null = no change)\nSeparates computation from coordination\nEnables testability without mocking\nSize: ~24 bytes", fillcolor=wheat, shape=note];
    }

    // ========== CPU LOGIC (src/cpu/Logic.zig) ==========
    subgraph cluster_cpu_logic {
        label="CpuLogic (src/cpu/Logic.zig)\nPure Functions - No Hidden State";
        style=filled;
        fillcolor=skyblue;

        logic_init [label="init() CpuState\n// Power-on state\n// Returns new CpuState", fillcolor=lightblue];

        logic_reset [label="reset(cpu: *CpuState, reset_vector: u16) void\n// RESET interrupt processing\n// SIDE EFFECTS:\n// - Decrement SP by 3\n// - Set interrupt disable\n// - Jump to vector\n// - Clear halted state", fillcolor=lightblue];

        logic_core [label="toCoreState(cpu: *const CpuState) CpuCoreState\n// Extract 6502 registers + effective_address\n// Pure: No side effects", fillcolor=palegreen];

        logic_check_int [label="checkInterrupts(state: *CpuState) void\n// Check and latch interrupt signals\n// NMI: edge-triggered (falling edge)\n// IRQ: level-triggered\n// SIDE EFFECTS:\n// - Sets pending_interrupt", fillcolor=lightcoral];

        logic_start_int [label="startInterruptSequence(state: *CpuState) void\n// Begin hardware interrupt (7 cycles)\n// SIDE EFFECTS:\n// - Set state to .interrupt_sequence\n// - Reset instruction_cycle to 0", fillcolor=lightcoral];
    }

    // ========== EXECUTION ENGINE (src/emulation/cpu/execution.zig) ==========
    subgraph cluster_execution {
        label="Execution Engine (src/emulation/cpu/execution.zig)\nCycle-Accurate State Machine";
        style=filled;
        fillcolor=lightyellow;

        exec_step [label="stepCycle(state: anytype) CpuCycleResult\n// Entry point for one CPU cycle\n// SIDE EFFECTS:\n// - Queries VBlankLedger for NMI\n// - Checks PPU warmup (29658 cycles)\n// - Handles CPU halted state\n// - Checks debugger breakpoints\n// - Handles DMC/OAM DMA\n// - Calls executeCycle()\n// - Polls mapper IRQ", fillcolor=yellow, shape=box3d];

        exec_execute [label="executeCycle(state: anytype) void\n// Execute CPU micro-operations\n// State Machine Dispatcher:\n// - .interrupt_sequence (7 cycles)\n// - .fetch_opcode (1 cycle)\n// - .fetch_operand_low (1-8 cycles)\n// - .execute (1 cycle)\n// SIDE EFFECTS:\n// - Advances state machine\n// - Calls busRead/Write\n// - May complete instruction", fillcolor=lightgreen, shape=box3d];
    }

    // ========== MICROSTEPS (src/emulation/cpu/microsteps.zig) ==========
    subgraph cluster_microsteps {
        label="Microsteps (src/emulation/cpu/microsteps.zig)\nAtomic Hardware Operations";
        style=filled;
        fillcolor=lightgoldenrodyellow;

        micro_fetch [label="Fetch Operations:\nfetchAbsLow(state)\nfetchAbsHigh(state)\nfetchZeroPage(state)\n// SIDE EFFECTS:\n// - busRead() at PC\n// - Increment PC\n// - Store in operand_low/high", fillcolor=wheat, shape=record];

        micro_addr [label="Address Calculations:\ncalcAbsoluteX(state)\ncalcAbsoluteY(state)\ncalcIndirect(state)\n// SIDE EFFECTS:\n// - May busRead() on page cross\n// - Set effective_address\n// - Set page_crossed flag", fillcolor=wheat, shape=record];

        micro_stack [label="Stack Operations:\npushByte(state, value)\npopByte(state) u8\npush16(state, value)\npop16(state) u16\n// SIDE EFFECTS:\n// - busWrite/Read $0100-$01FF\n// - Modify SP", fillcolor=lightcoral, shape=record];
    }

    // ========== DISPATCH (src/cpu/dispatch.zig) ==========
    subgraph cluster_dispatch {
        label="Dispatch Table (src/cpu/dispatch.zig)\n256 Opcode Entries";
        style=filled;
        fillcolor=lightsteelblue;

        dispatch_table [label="DISPATCH_TABLE: [256]DispatchEntry\nBuilt at comptime via buildDispatchTable()\n\nDispatchEntry struct:\noperation: OpcodeFn\ninfo: OpcodeInfo\nis_rmw: bool = false\nis_pull: bool = false", fillcolor=lightsteelblue, shape=record];

        dispatch_opcode_fn [label="OpcodeFn signature:\n*const fn(CpuCoreState, u8) OpcodeResult\n\nTakes: Core CPU state (read-only) + operand\nReturns: Delta structure (OpcodeResult)", fillcolor=lightsteelblue, shape=record];

        dispatch_lookup [label="Lookup by opcode byte:\nentry = DISPATCH_TABLE[opcode]\n\nUsage in executeCycle:\nconst entry = DISPATCH_TABLE[state.cpu.opcode]\nconst result = entry.operation(core_state, operand)", fillcolor=lightblue];
    }

    // ========== OPCODES (src/cpu/opcodes/) ==========
    subgraph cluster_opcodes {
        label="Opcode Implementations (src/cpu/opcodes/)\nPure Functions - Return Deltas";
        style=filled;
        fillcolor=palegreen;

        subgraph cluster_opcode_modules {
            label="Modules by Category";
            style=dashed;

            op_arithmetic [label="arithmetic.zig:\nadc, sbc\n// ADC/SBC with carry\n// Set N, V, Z, C flags", fillcolor=palegreen];
            op_logical [label="logical.zig:\nand, ora, eor\n// Bitwise operations\n// Set N, Z flags", fillcolor=palegreen];
            op_shifts [label="shifts.zig:\nasl, lsr, rol, ror\n// Shift/rotate\n// Set N, Z, C flags", fillcolor=palegreen];
            op_compare [label="compare.zig:\ncmp, cpx, cpy, bit\n// Compare/test\n// Set N, Z, C flags\n// BIT: Copy V, N from memory", fillcolor=palegreen];
            op_loadstore [label="loadstore.zig:\nlda, ldx, ldy, sta, stx, sty\n// Load/store registers\n// Set N, Z on loads", fillcolor=palegreen];
            op_transfer [label="transfer.zig:\ntax, tay, txa, tya, tsx, txs\n// Register transfers\n// Set N, Z (except TXS)", fillcolor=palegreen];
            op_incdec [label="incdec.zig:\ninc, dec, inx, dex, iny, dey\n// Increment/decrement\n// Set N, Z flags", fillcolor=palegreen];
            op_branch [label="branch.zig:\nbcc, bcs, beq, bne, etc.\n// Conditional branches\n// Modify PC on condition", fillcolor=palegreen];
            op_jumps [label="jumps.zig (control.zig):\njmp, jsr, rts, rti\n// Unconditional flow\n// Stack operations", fillcolor=palegreen];
            op_stack [label="stack.zig:\npha, pla, php, plp\n// Stack push/pop\n// PLP restores flags", fillcolor=palegreen];
            op_flags [label="flags.zig:\nsec, clc, sei, cli, sed, cld, clv\n// Flag manipulation\n// Direct flag sets/clears", fillcolor=palegreen];
            op_control [label="control.zig:\nbrk, nop\n// BRK: Software interrupt\n// NOP: No operation", fillcolor=palegreen];
            op_unofficial [label="unofficial.zig:\nslo, rla, sre, etc.\n// Unofficial opcodes\n// Combined operations", fillcolor=lightgray];
        }

        opcode_signature [label="Common Signature:\nfn(state: CpuCoreState, operand: u8) OpcodeResult\n\nSee cluster_opcode_result for full\nOpcodeResult structure definition\n\nPure function design:\n- Immutable input (CpuCoreState)\n- No side effects\n- Returns delta structure\n- Execution engine applies result", fillcolor=wheat, shape=note];
    }

    // ========== DECODE (src/cpu/decode.zig) ==========
    subgraph cluster_decode {
        label="Decode Table (src/cpu/decode.zig)\nOpcode Metadata";
        style=filled;
        fillcolor=lightyellow;

        decode_table [label="OPCODE_TABLE: [256]OpcodeInfo\nBuilt at comptime\n\nOpcodeInfo struct:\nmnemonic: []const u8\nmode: AddressingMode\ncycles: u8\npage_cross_cycle: bool = false\nunofficial: bool = false", fillcolor=lightyellow, shape=record];

        decode_modes [label="AddressingMode enum (13 modes):\n.implied\n.accumulator\n.immediate\n.zero_page\n.zero_page_x\n.zero_page_y\n.absolute\n.absolute_x\n.absolute_y\n.indirect\n.indexed_indirect\n.indirect_indexed\n.relative", fillcolor=wheat, shape=record];
    }

    // ========== STATUS FLAGS (src/cpu/State.zig) ==========
    subgraph cluster_flags {
        label="StatusFlags (CPU P Register)\nNVBDIZC Bits";
        style=filled;
        fillcolor=lightyellow;

        flags_struct [label="StatusFlags packed struct(u8):\ncarry: bool = false       // C - Bit 0\nzero: bool = false        // Z - Bit 1\ninterrupt: bool = false   // I - Bit 2\ndecimal: bool = false     // D - Bit 3 (ignored on NES)\nbreak_flag: bool = false  // B - Bit 4 (stack only)\nunused: bool = true       // - - Bit 5 (always 1)\noverflow: bool = false    // V - Bit 6\nnegative: bool = false    // N - Bit 7", fillcolor=lightyellow, shape=record];

        flags_functions [label="Functions:\ntoByte(self) u8\n  // Serialize to byte via @bitCast\n\nfromByte(byte: u8) StatusFlags\n  // Deserialize via @bitCast\n  // Forces unused bit to 1\n\nsetZN(self, value: u8) StatusFlags\n  // Returns NEW flags with Z,N set\n  // Pure function (no mutation)\n\nsetCarry(self, carry: bool) StatusFlags\nsetOverflow(self, overflow: bool) StatusFlags", fillcolor=wheat];
    }

    // ========== VARIANTS (src/cpu/variants.zig) ==========
    subgraph cluster_variants {
        label="Variants (src/cpu/variants.zig)\nCPU Model Differences";
        style=filled;
        fillcolor=lightgray;

        variants_note [label="CpuVariant enum:\n  .NMOS_6502  // Original\n  .CMOS_65C02 // Bugfixes\n  .Ricoh_2A03 // NES (decimal disabled)\n  .Ricoh_2A07 // PAL NES\n\nUsed for edge case behavior", fillcolor=lightgray, shape=note];
    }

    // ========== MAIN DATA FLOW ==========

    // Main execution flow: EmulationState.tick() -> stepCycle() -> executeCycle()
    // NOTE: cpu_tick, logic_tick, exec_fetch, exec_operand, exec_writeback, exec_interrupt_check removed
    // These nodes don't exist in actual architecture

    // Entry point: EmulationState calls stepCycle
    exec_step -> exec_execute [label="calls", color=blue, penwidth=2];

    // executeCycle is inline state machine dispatcher
    exec_execute -> micro_fetch [label=".fetch_opcode:\nread opcode at PC", color=green];
    exec_execute -> micro_addr [label=".fetch_operand_low:\naddressing microsteps", color=green];
    exec_execute -> dispatch_lookup [label=".execute:\nlookup + call opcode", color=purple, penwidth=2];

    // Dispatch flow
    dispatch_lookup -> dispatch_table [label="index by opcode", color=purple];
    dispatch_table -> dispatch_opcode_fn [label="contains", style=dotted];
    dispatch_table -> op_arithmetic [lhead=cluster_opcode_modules, label="operation field", color=green];

    // Decode table used during fetch
    exec_execute -> decode_table [label=".fetch_opcode:\nget mode/cycles", style=dashed];

    // Microsteps used during addressing
    micro_addr -> micro_stack [label="for control flow\n(JSR/RTS/RTI/BRK)", style=dashed, color=orange];

    // Interrupt handling via Logic module
    exec_execute -> logic_check_int [label="at .fetch_opcode", style=dashed, color=red];
    logic_check_int -> logic_start_int [label="if pending", color=red];
    logic_start_int -> micro_stack [label=".interrupt_sequence:\npush PC, P", color=red];

    // Pure opcode functions use CpuCoreState
    logic_core -> core_state [label="extracts", color=green];
    op_arithmetic -> core_state [lhead=cluster_opcode_modules, ltail=cluster_opcode_modules, label="accepts", color=green, style=dashed];
    op_arithmetic -> opcode_result [lhead=cluster_opcode_modules, ltail=cluster_opcode_modules, label="returns", color=orange, style=dashed];

    // OpcodeResult contains BusWrite
    opcode_result -> result_buswrite [label="contains", style=dotted];

    // Flags used throughout
    cpu_regs -> flags_struct [label="contains", style=dotted];
    core_state -> flags_struct [label="contains", style=dotted];
    opcode_result -> flags_struct [label="may update", color=orange, style=dashed];

    // Legend
    subgraph cluster_legend {
        label="Legend";
        style=filled;
        fillcolor=white;
        rank=sink;

        legend_call [label="Solid: Direct call/contains", penwidth=2];
        legend_delegate [label="Blue: Main execution flow", color=blue, penwidth=2];
        legend_data [label="Dashed: Data lookup/usage", style=dashed];
        legend_side [label="Orange: Mutation/side effect", color=orange];
        legend_interrupt [label="Red: Interrupt flow", color=red];
    }

    // Ownership annotation
    subgraph cluster_ownership {
        label="Ownership & Lifetime";
        style=filled;
        fillcolor=white;
        rank=sink;

        own_state [label="CpuState:\nOwned by EmulationState\nStack-allocated\nNo heap usage", fillcolor=lightcyan, shape=note];
        own_logic [label="Logic Functions:\nStateless pure functions\nNo allocations\nRT-safe", fillcolor=palegreen, shape=note];
        own_tables [label="Dispatch/Decode Tables:\nComptime-initialized const\nRead-only\nZero-cost", fillcolor=lightyellow, shape=note];
    }

    // Side effects summary
    subgraph cluster_side_effects {
        label="Side Effects Summary";
        style=filled;
        fillcolor=white;
        rank=sink;

        side_mutation [label="State Mutation:\n- CPU registers (A, X, Y, SP, PC, P)\n- Execution state machine fields\n- Interrupt pending flags", fillcolor=lightyellow, shape=note];
        side_bus [label="Bus I/O:\n- busRead() at PC, operand addresses\n- busWrite() for STA, stack ops, RMW\n- Open bus updates", fillcolor=lightcoral, shape=note];
        side_timing [label="Timing:\n- Instruction cycle counter\n- Page cross detection\n- Dummy reads on address fixup", fillcolor=wheat, shape=note];
    }
}
