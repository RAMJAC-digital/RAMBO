// Cartridge and Mailbox Systems - Comptime Generics + Lock-Free Communication
// Based on actual source code audit from docs/architecture/codebase-inventory.md
// Shows zero-cost polymorphism and RT-safe inter-thread communication

digraph Cartridge_Mailbox_Systems {
    // Graph settings
    rankdir=TB;
    compound=true;
    splines=ortho;
    nodesep=0.6;
    ranksep=1.2;

    // Node defaults
    node [shape=box, style=filled, fillcolor=lightgray, fontname="Arial", fontsize=10];
    edge [fontname="Arial", fontsize=9];

    // ========== CARTRIDGE SYSTEM ==========
    subgraph cluster_cartridge_system {
        label="Cartridge System (src/cartridge/)\nComptime Generics - Zero-Cost Polymorphism";
        style=filled;
        fillcolor=lightblue;

        // ===== Generic Cartridge =====
        subgraph cluster_generic_cartridge {
            label="Generic Cartridge(MapperType) - Comptime Type Factory";
            style=dashed;
            fillcolor=lightcyan;

            cart_generic [label="Cartridge(comptime MapperType: type) type\n\nType factory returns struct with:\n- mapper: MapperType         // Direct containment (no pointer)\n- prg_rom: []const u8        // Immutable ROM data\n- chr_data: []u8             // ROM or RAM\n- prg_ram: ?[]u8             // Battery-backed RAM ($6000-$7FFF)\n- header: InesHeader         // Metadata\n- mirroring: Mirroring       // Nametable mode\n- allocator: Allocator       // For cleanup\n\nDuck-Typed Mapper Interface:\n- cpuRead(mapper, cart, addr) u8\n- cpuWrite(mapper, cart, addr, value)\n- ppuRead(mapper, cart, addr) u8\n- ppuWrite(mapper, cart, addr, value)\n- reset(mapper, cart)\n- tickIrq(mapper) bool\n- ppuA12Rising(mapper)\n- acknowledgeIrq(mapper)", fillcolor=lightcyan, shape=record];

            cart_load [label="loadFromData(allocator, data) !Self\n// Parse iNES header\n// Allocate ROM/RAM\n// Initialize mapper\n// SIDE EFFECTS:\n// - Heap allocations for ROM/RAM\n// - Parser validates header", fillcolor=wheat];

            cart_deinit [label="deinit(self) void\n// Free allocated memory", fillcolor=lightblue];

            cart_cpu_read [label="cpuRead(self, addr) u8\n// Delegate to mapper.cpuRead()", fillcolor=lightgreen];

            cart_cpu_write [label="cpuWrite(self, addr, value)\n// Delegate to mapper.cpuWrite()", fillcolor=lightcoral];

            cart_ppu_read [label="ppuRead(self, addr) u8\n// Delegate to mapper.ppuRead()", fillcolor=lightgreen];

            cart_ppu_write [label="ppuWrite(self, addr, value)\n// Delegate to mapper.ppuWrite()", fillcolor=lightcoral];

            cart_reset [label="reset(self) void\n// Delegate to mapper.reset()", fillcolor=wheat];
        }

        // ===== Mapper Registry =====
        subgraph cluster_mapper_registry {
            label="Mapper Registry (src/cartridge/mappers/registry.zig)";
            style=dashed;
            fillcolor=lightyellow;

            mapper_id [label="MapperId enum(u8):\n  .nrom = 0     // Mapper 0: NROM (248 games)\n  // Future:\n  // .mmc1 = 1   // Mapper 1: MMC1 (681 games)\n  // .uxrom = 2  // Mapper 2: UxROM (270 games)\n  // .cnrom = 3  // Mapper 3: CNROM (155 games)\n  // .mmc3 = 4   // Mapper 4: MMC3 (600 games)", fillcolor=lightyellow, shape=record];

            mapper_metadata [label="MapperMetadata struct:\nid: MapperId\nname: []const u8\ndescription: []const u8\nnesdev_link: []const u8\ngame_count: u16\nsupports_irq: bool\n\nget(id: MapperId) MapperMetadata", fillcolor=lightyellow, shape=record];

            any_cartridge [label="AnyCartridge union(MapperId):\n  .nrom: Cartridge(Mapper0)\n  // Future variants:\n  // .mmc1: Cartridge(Mapper1)\n  // .uxrom: Cartridge(Mapper2)\n  // .cnrom: Cartridge(Mapper3)\n  // .mmc3: Cartridge(Mapper4)\n\nTagged union dispatch:\n- Uses 'inline else' for zero-overhead\n- Compiles to direct jumps (no VTable)\n- Each variant is distinct type", fillcolor=lightblue, shape=record];

            any_cart_cpu_read [label="cpuRead(self, addr) u8\nswitch (self.*) {\n  inline else => |*cart| cart.cpuRead(addr)\n}\n\nCompiler inlines all variants", fillcolor=lightgreen];

            any_cart_cpu_write [label="cpuWrite(self, addr, value)\nswitch (self.*) {\n  inline else => |*cart| cart.cpuWrite(addr, value)\n}", fillcolor=lightcoral];

            any_cart_ppu_read [label="ppuRead(self, addr) u8", fillcolor=lightgreen];
            any_cart_ppu_write [label="ppuWrite(self, addr, value)", fillcolor=lightcoral];

            any_cart_tick_irq [label="tickIrq(self) bool\n// Poll mapper for IRQ\n// Returns false for NROM", fillcolor=yellow];

            any_cart_a12 [label="ppuA12Rising(self)\n// MMC3 IRQ counter\n// No-op for NROM", fillcolor=wheat];

            any_cart_ack_irq [label="acknowledgeIrq(self)\n// Clear IRQ pending\n// No-op for NROM", fillcolor=wheat];

            any_cart_reset [label="reset(self)", fillcolor=wheat];
            any_cart_mirroring [label="getMirroring(self) Mirroring", fillcolor=lightgreen];
            any_cart_metadata [label="getMetadata(self) MapperMetadata", fillcolor=lightgreen];
        }

        // ===== Mapper 0 (NROM) =====
        subgraph cluster_mapper0 {
            label="Mapper0 (src/cartridge/mappers/Mapper0.zig)\nNROM - Simplest Mapper (No Banking)";
            style=dashed;
            fillcolor=palegreen;

            mapper0_struct [label="Mapper0 struct:\n// No state - behavior determined by ROM size\n\nPRG ROM Mapping ($8000-$FFFF):\n- 32KB: Direct mapping\n  $8000-$BFFF → ROM[0x0000-0x3FFF]\n  $C000-$FFFF → ROM[0x4000-0x7FFF]\n- 16KB: Mirrored\n  $8000-$BFFF → ROM[0x0000-0x3FFF]\n  $C000-$FFFF → ROM[0x0000-0x3FFF] (mirror)\n\nPRG RAM ($6000-$7FFF):\n- 8KB if present, else open bus (0xFF)\n\nCHR (PPU $0000-$1FFF):\n- 8KB ROM: Read-only\n- CHR RAM: Writable", fillcolor=palegreen, shape=record];

            mapper0_cpu_read [label="cpuRead(_self, cart, addr) u8\n// Duck-typed: cart has .prg_rom, .prg_ram\n$6000-$7FFF: PRG RAM (if present)\n$8000-$FFFF: PRG ROM (mirrored if 16KB)", fillcolor=lightgreen];

            mapper0_cpu_write [label="cpuWrite(_self, cart, addr, value)\n// PRG RAM writable at $6000-$7FFF\n// PRG ROM writes ignored", fillcolor=lightcoral];

            mapper0_ppu_read [label="ppuRead(_self, cart, addr) u8\n// CHR ROM/RAM at $0000-$1FFF", fillcolor=lightgreen];

            mapper0_ppu_write [label="ppuWrite(_self, cart, addr, value)\n// Writable if CHR RAM", fillcolor=lightcoral];

            mapper0_stubs [label="Stubs (no IRQ support):\ntickIrq() bool → false\nppuA12Rising() → no-op\nacknowledgeIrq() → no-op\nreset(cart) → no-op", fillcolor=lightgray];
        }

        // ===== iNES Parser =====
        subgraph cluster_ines {
            label="iNES Parser (src/cartridge/ines/)";
            style=dashed;
            fillcolor=wheat;

            ines_header [label="InesHeader struct:\nmagic: [4]u8           // 'NES\\x1A'\nprg_rom_size: u8       // 16KB units\nchr_rom_size: u8       // 8KB units\nflags6: u8             // Mapper low, mirroring\nflags7: u8             // Mapper high, format\nflags8: u8             // PRG RAM size\nflags9: u8             // TV system\nflags10: u8            // Rarely used\n\nparse(data: []const u8) !InesHeader\ngetMapperNumber() u8\ngetMirroring() Mirroring\nhasTrainer() bool", fillcolor=wheat, shape=record];

            ines_mirroring [label="Mirroring enum:\n  .horizontal  // Bit 0 = 0\n  .vertical    // Bit 0 = 1\n  .four_screen // Bit 3 = 1", fillcolor=wheat, shape=record];

            ines_error [label="InesError:\nInvalidMagic\nInvalidFormat\nUnsupportedVersion", fillcolor=lightcoral, shape=record];
        }
    }

    // ========== MAILBOX SYSTEM ==========
    subgraph cluster_mailbox_system {
        label="Mailbox System (src/mailboxes/)\nLock-Free Inter-Thread Communication";
        style=filled;
        fillcolor=lavender;

        // ===== Mailboxes Container =====
        subgraph cluster_mailboxes_container {
            label="Mailboxes (src/mailboxes/Mailboxes.zig)\nCentral Container - By-Value Ownership";
            style=dashed;
            fillcolor=lightblue;

            mailboxes_struct [label="Mailboxes struct:\n// Emulation Input (Main → Emulation)\ncontroller_input: ControllerInputMailbox\nemulation_command: EmulationCommandMailbox\ndebug_command: DebugCommandMailbox\n\n// Emulation Output (Emulation → Render/Main)\nframe: FrameMailbox\ndebug_event: DebugEventMailbox\n\n// Render Thread (Render ↔ Main)\nxdg_window_event: XdgWindowEventMailbox\nxdg_input_event: XdgInputEventMailbox\n\nBy-value ownership prevents leaks\nPass pointers for dependency injection", fillcolor=lightblue, shape=record];

            mailboxes_init [label="init(allocator) Mailboxes\n// Initialize all mailboxes", fillcolor=wheat];
            mailboxes_deinit [label="deinit(self) void\n// Cleanup all mailboxes", fillcolor=lightcoral];
        }

        // ===== Frame Mailbox =====
        subgraph cluster_frame_mailbox {
            label="FrameMailbox (src/mailboxes/FrameMailbox.zig)\nLock-Free Triple-Buffered Frame Data";
            style=dashed;
            fillcolor=yellow;

            frame_const [label="Constants:\nFRAME_WIDTH = 256\nFRAME_HEIGHT = 240\nFRAME_PIXELS = 61,440\nRING_BUFFER_SIZE = 3  // Triple-buffering\n\nFrameBuffer = [61440]u32  // RGBA (0xAABBGGRR)", fillcolor=yellow, shape=record];

            frame_state [label="FrameMailbox:\nbuffers: [3]FrameBuffer     // Stack-allocated (720 KB)\nwrite_index: atomic.Value(u32)\nread_index: atomic.Value(u32)\nframe_count: atomic.Value(u64)\nframes_dropped: atomic.Value(u64)\n\nCRITICAL: Stack-allocated for RT-safety\nZERO heap allocations after init()", fillcolor=yellow, shape=record];

            frame_init [label="init() FrameMailbox\n// All buffers zeroed\n// Pure atomic - no allocator", fillcolor=wheat];

            frame_get_write [label="getWriteBuffer(self) ?[]u32\n// Returns current write buffer\n// Null if ring buffer full\n// SIDE EFFECTS:\n// - Atomic load write_index\n// - Atomic load read_index", fillcolor=lightgreen];

            frame_swap [label="swapBuffers(self) void\n// Publish completed frame\n// SIDE EFFECTS:\n// - Atomic increment write_index\n// - Increment frame_count\n// - Increment frames_dropped (if overflow)", fillcolor=lightcoral, shape=box3d];

            frame_get_read [label="getReadBuffer(self) ?[]const u32\n// Returns buffer for rendering\n// Null if no new frames", fillcolor=lightgreen];

            frame_consume [label="consumeFrame(self) void\n// Mark frame consumed\n// SIDE EFFECTS:\n// - Atomic increment read_index", fillcolor=wheat];

            frame_stats [label="getFrameCount() u64\ngetFramesDropped() u64\n// Pure: Atomic loads only", fillcolor=lightgreen];
        }

        // ===== SPSC Ring Buffer =====
        subgraph cluster_spsc_ring {
            label="SpscRingBuffer (src/mailboxes/SpscRingBuffer.zig)\nGeneric Lock-Free Ring Buffer";
            style=dashed;
            fillcolor=lightgreen;

            spsc_generic [label="SpscRingBuffer(comptime T: type, comptime capacity: usize) type\n\nConstraint: capacity MUST be power of 2\n\nReturns struct:\nbuffer: [capacity]T\nwrite_index: atomic.Value(usize)\nread_index: atomic.Value(usize)\n\nSPSC: Single Producer Single Consumer\nLock-free: Pure atomic operations", fillcolor=lightgreen, shape=record];

            spsc_push [label="push(self, item: T) bool\n// Producer thread only\n// Returns false if full\n// SIDE EFFECTS:\n// - Write to buffer[write]\n// - Atomic store write_index (release)", fillcolor=lightcoral];

            spsc_pop [label="pop(self) ?T\n// Consumer thread only\n// Returns null if empty\n// SIDE EFFECTS:\n// - Read from buffer[read]\n// - Atomic store read_index (release)", fillcolor=lightgreen];

            spsc_query [label="isEmpty(self) bool\nisFull(self) bool\n// Either thread\n// Pure: Atomic loads only", fillcolor=lightgreen];
        }

        // ===== Controller Input Mailbox =====
        subgraph cluster_controller_mailbox {
            label="ControllerInputMailbox\nNES Button State (Main → Emulation)";
            style=dashed;
            fillcolor=lightcyan;

            controller_mailbox [label="ControllerInputMailbox:\lMutex-Protected State (NOT SpscRingBuffer)\l\lControllerInput struct:\lcontroller1: ButtonState\lcontroller2: ButtonState\l\lButtonState struct:\la: bool, b: bool\lselect: bool, start: bool\lup: bool, down: bool\lleft: bool, right: bool\l\lMethods:\lpostInput(input) - locked write\lreadInput() - locked read\l\lMain writes: Wayland key events\lEmulation reads: Controller.updateButtons()\l", fillcolor=lightcyan, shape=box];
        }

        // ===== Debug Mailboxes =====
        subgraph cluster_debug_mailboxes {
            label="Debug Mailboxes (Bidirectional)";
            style=dashed;
            fillcolor=lightblue;

            debug_command_mailbox [label="DebugCommandMailbox:\lMain → Emulation\l\lUsing SpscRingBuffer(DebugCommand, 32)\l\lDebugCommand union(enum):\l  .add_breakpoint(address, type)\l  .remove_breakpoint(address, type)\l  .add_watchpoint(address, size, watch_type)\l  .remove_watchpoint(address, watch_type)\l  .pause\l  .resume_execution\l  .step_instruction\l  .step_frame\l  .inspect\l  .reset\l\lLock-free SPSC ring buffer\l", fillcolor=lightblue, shape=box];

            debug_event_mailbox [label="DebugEventMailbox:\lEmulation → Main\l\lUsing SpscRingBuffer(DebugEvent, 32)\l\lDebugEvent union(enum):\l  .breakpoint_hit(address, bp_type)\l  .watchpoint_hit(address, value, is_write, watch_type)\l  .inspect_response(snapshot)\l\lCpuSnapshot struct:\lpc: u16, sp: u8\la: u8, x: u8, y: u8\lp: StatusFlags\lopcode: u8\ninstruction_cycle: u8\l\lLock-free SPSC ring buffer\l", fillcolor=lightblue, shape=box];
        }

        // ===== Window/Input Mailboxes =====
        subgraph cluster_window_mailboxes {
            label="Window/Input Mailboxes (Render ↔ Main)";
            style=dashed;
            fillcolor=lavender;

            xdg_window_mailbox [label="XdgWindowEventMailbox:\nRender → Main\n\nXdgWindowEvent enum:\n  .configure(width, height)\n  .close_requested\n  .frame_done\n\nUsing SpscRingBuffer", fillcolor=lavender, shape=record];

            xdg_input_mailbox [label="XdgInputEventMailbox:\nRender → Main\n\nXdgInputEvent enum:\n  .key_press(key)\n  .key_release(key)\n  .pointer_motion(x, y)\n  .pointer_button(button, pressed)\n\nUsing SpscRingBuffer", fillcolor=lavender, shape=record];
        }

        // ===== Emulation Command Mailbox =====
        subgraph cluster_emulation_command {
            label="EmulationCommandMailbox\nMain → Emulation Control";
            style=dashed;
            fillcolor=wheat;

            emulation_command_mailbox [label="EmulationCommandMailbox:\nUsing SpscRingBuffer\n\nCommands:\n  .load_rom(path)\n  .reset\n  .save_state\n  .load_state\n  .set_speed(multiplier)\n\nEmulation thread polls and processes", fillcolor=wheat, shape=record];
        }
    }

    // ========== DATA FLOW ==========

    // Cartridge generics
    cart_generic -> cart_load [label="factory", style=dashed];
    cart_generic -> cart_cpu_read [lhead=cluster_generic_cartridge, label="methods", style=dotted];
    cart_load -> ines_header [label="parses", color=blue];

    // AnyCartridge dispatch
    any_cartridge -> any_cart_cpu_read [label="contains methods", style=dotted];
    any_cart_cpu_read -> cart_cpu_read [label="inline dispatch", color=green];
    any_cart_cpu_write -> cart_cpu_write [label="inline dispatch", color=red];
    any_cart_ppu_read -> cart_ppu_read [label="inline dispatch", color=green];
    any_cart_ppu_write -> cart_ppu_write [label="inline dispatch", color=red];

    // Mapper delegation
    cart_cpu_read -> mapper0_cpu_read [label="delegates", color=green];
    cart_cpu_write -> mapper0_cpu_write [label="delegates", color=red];
    cart_ppu_read -> mapper0_ppu_read [label="delegates", color=green];
    cart_ppu_write -> mapper0_ppu_write [label="delegates", color=red];

    // Mailboxes container
    mailboxes_struct -> frame_state [label="owns by value", style=dotted];
    mailboxes_struct -> controller_mailbox [label="owns by value", style=dotted];
    mailboxes_struct -> debug_command_mailbox [label="owns by value", style=dotted];

    // Frame mailbox operations
    frame_state -> frame_get_write [label="contains", style=dotted];
    frame_get_write -> frame_swap [label="write → swap", color=blue];
    frame_get_read -> frame_consume [label="read → consume", color=green];

    // SPSC usage
    controller_mailbox -> spsc_generic [label="uses", style=dashed];
    xdg_window_mailbox -> spsc_generic [label="uses", style=dashed];

    // Mapper metadata
    mapper_id -> mapper_metadata [label="provides", style=dashed];
    any_cartridge -> mapper_id [label="tagged by", style=dotted];

    // Legend
    subgraph cluster_legend {
        label="Legend";
        style=filled;
        fillcolor=white;
        rank=sink;

        legend_solid [label="Solid: Direct call", penwidth=2];
        legend_dashed [label="Dashed: Factory/uses", style=dashed];
        legend_dotted [label="Dotted: Containment", style=dotted];
        legend_green [label="Green: Read operations", color=green];
        legend_red [label="Red: Write operations", color=red];
        legend_blue [label="Blue: Flow/coordination", color=blue];
    }

    // Critical features
    subgraph cluster_critical_features {
        label="Critical Architecture Features";
        style=filled;
        fillcolor=white;
        rank=sink;

        feature_comptime [label="Comptime Generics (Zero-Cost Polymorphism):\n- Cartridge(MapperType) is type factory\n- Each instantiation is distinct type\n- Duck typing via 'anytype' parameters\n- NO VTable overhead\n- All dispatch via 'inline else' (direct jumps)\n- Mapper state directly contained (no pointers)", fillcolor=yellow, shape=note];

        feature_lockfree [label="Lock-Free Mailboxes:\n- Pure atomic operations (NO mutexes)\n- SPSC: Single Producer Single Consumer\n- Power-of-2 capacity for fast modulo (bitwise AND)\n- Release/Acquire semantics for visibility\n- Wait-free when not full/empty\n- Triple-buffering for frame data (prevent tearing)", fillcolor=yellow, shape=note];

        feature_rtsafe [label="RT-Safety Guarantees:\n- FrameMailbox: 720 KB stack-allocated\n- ZERO heap allocations after init()\n- No GC pauses, no allocator contention\n- Deterministic latency\n- Critical for 60 FPS emulation", fillcolor=yellow, shape=note];

        feature_ownership [label="Ownership Model:\n- Mailboxes: By-value in container\n- Cartridge: EmulationState owns AnyCartridge\n- ROM data: Owned by cartridge (heap)\n- Frame buffers: Owned by mailbox (stack)\n- No shared mutable state between threads", fillcolor=yellow, shape=note];
    }

    // Hardware correspondence
    subgraph cluster_hardware {
        label="Hardware Correspondence";
        style=filled;
        fillcolor=white;
        rank=sink;

        hw_cartridge [label="NES Cartridge Hardware:\n- PRG ROM: Program memory ($8000-$FFFF)\n- CHR ROM/RAM: Pattern tables ($0000-$1FFF)\n- PRG RAM: Battery-backed save RAM ($6000-$7FFF)\n- Mapper chip: Bank switching logic\n- Mirroring: Nametable arrangement (H/V/4-screen)\n- IRQ: Scanline counters (MMC3) or audio (MMC5)", fillcolor=wheat, shape=note];

        hw_mappers [label="Mapper Coverage:\nMapper 0 (NROM): 248 games (~5%)\n  Super Mario Bros., Donkey Kong\n\nPhase 1 Target (4 more mappers):\n  Total: 75% game coverage\n  MMC1, UxROM, CNROM, MMC3", fillcolor=wheat, shape=note];

        hw_frame_format [label="NES PPU Output:\n256×240 pixels per frame\n60.0988 Hz (NTSC)\nRGBA u32 format: 0xAABBGGRR\nVulkan-compatible layout", fillcolor=wheat, shape=note];
    }

    // Mailbox flow diagram
    subgraph cluster_mailbox_flow {
        label="Mailbox Communication Flow";
        style=filled;
        fillcolor=white;
        rank=sink;

        flow_diagram [label="Thread Communication:\n\nMain Thread:\n  → controller_input.push(buttons)\n  → debug_command.push(cmd)\n  ← debug_event.pop()\n  ← xdg_window_event.pop()\n\nEmulation Thread:\n  ← controller_input.pop()\n  ← debug_command.pop()\n  → frame.swapBuffers()\n  → debug_event.push(event)\n\nRender Thread:\n  ← frame.getReadBuffer()\n  → xdg_window_event.push(event)\n  → xdg_input_event.push(input)\n\nLock-Free: No mutex contention\nSPSC: No ABA problem", fillcolor=lavender, shape=note];
    }

    // Performance notes
    subgraph cluster_performance {
        label="Performance Characteristics";
        style=filled;
        fillcolor=white;
        rank=sink;

        perf_cartridge [label="Cartridge Performance:\n- cpuRead: ~5-10 ns (inline, no indirection)\n- Memory layout: Sequential ROM access\n- Mapper dispatch: Zero-cost (comptime)\n- No heap allocations in hot path\n- Cache-friendly: ROM is const, PRG RAM is small", fillcolor=lightgreen, shape=note];

        perf_mailbox [label="Mailbox Performance:\n- Frame swap: ~50-100 ns (3 atomic ops)\n- Ring buffer: O(1) push/pop\n- No syscalls in hot path\n- No memory barriers (only atomic ops)\n- Triple-buffering: 720 KB (fits L2 cache)", fillcolor=lightgreen, shape=note];

        perf_atomic [label="Atomic Memory Ordering:\n- .monotonic: Fastest (no barriers)\n- .acquire: Load barrier (read synchronization)\n- .release: Store barrier (write publish)\n- .seq_cst: Full fence (not used)\n\nSPSC pattern allows weaker ordering", fillcolor=lightgreen, shape=note];
    }
}
