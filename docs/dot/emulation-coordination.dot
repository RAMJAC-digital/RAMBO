// Emulation Coordination Layer - Complete System Integration
// Based on actual source code audit from docs/architecture/codebase-inventory.md
// Shows how CPU, PPU, APU, Bus, Cartridge, DMA, and Debugger coordinate
//
// UPDATED: 2025-10-16 - VBlankLedger refactor (Phase 4) and race_hold fix
// Changes: VBlankLedger is now pure data struct, PpuReadResult pattern added

digraph Emulation_Coordination {
    // Graph settings
    rankdir=TB;
    compound=true;
    splines=ortho;
    nodesep=0.6;
    ranksep=1.2;

    // Node defaults
    node [shape=box, style=filled, fillcolor=lightgray, fontname="Arial", fontsize=10];
    edge [fontname="Arial", fontsize=9];

    // ========== EMULATION STATE (src/emulation/State.zig) ==========
    subgraph cluster_emulation_state {
        label="EmulationState (src/emulation/State.zig)\nSingle Source of Truth - Direct Data Ownership";
        style=filled;
        fillcolor=lightblue;

        subgraph cluster_owned_components {
            label="Directly Owned Components";
            style=dashed;

            owned_state [label="Direct Ownership:\nclock: MasterClock          // PPU cycle counter\ncpu: CpuState               // 6502 state\nppu: PpuState               // 2C02 state\napu: ApuState               // APU state\nbus: BusState               // RAM + open bus\ncart: ?AnyCartridge         // Tagged union\ndma: OamDma                 // OAM DMA state machine\ndmc_dma: DmcDma             // DMC DMA state machine\ncontroller: ControllerState // NES controller\ndebugger: ?Debugger         // Breakpoints/watchpoints\nvblank_ledger: VBlankLedger // VBlank timestamps (PURE DATA)\n\nNo pointer wiring - all stack-allocated", fillcolor=lightcyan, shape=record];
        }

        subgraph cluster_emulation_flags {
            label="Emulation Flags";
            style=dashed;

            emu_flags [label="Runtime Flags:\nframe_complete: bool      // VBlank start\nodd_frame: bool           // Odd/even tracking\nrendering_enabled: bool   // PPU $2001 bits 3-4\ndebug_break_occurred: bool\n\nImmutable Configuration:\nconfig: *const Config     // Hardware config\n\nOptional Framebuffer:\nframebuffer: ?[]u32       // 256×240 RGBA", fillcolor=lightyellow, shape=record];
        }

        subgraph cluster_emulation_functions {
            label="Public API";
            style=dashed;

            emu_init [label="init(config) EmulationState\n// Power-on state", fillcolor=lightblue];
            emu_deinit [label="deinit(self) void\n// Cleanup cartridge", fillcolor=lightblue];
            emu_reset [label="reset(self) void\n// RESET button\n// Load PC from $FFFC", fillcolor=lightblue];
            emu_load_cart [label="loadCartridge(self, cart)\n// Takes ownership\n// Updates PPU mirroring", fillcolor=wheat];

            emu_tick [label="tick(self) void\n// RT emulation loop\n// Advances by 1 PPU cycle\n// CRITICAL: Single entry point", fillcolor=lightgreen, shape=box3d, penwidth=2];

            emu_helpers [label="Convenience Helpers:\nemulateFrame(self) u64\nemulateCpuCycles(self, n) u64\ntickCpuWithClock(self)\n// Delegates to helpers.zig", fillcolor=lightgray];
        }

        subgraph cluster_bus_routing {
            label="Bus Routing (Inline Logic)";
            style=dashed;

            bus_read [label="busRead(self, addr) u8\n// Route to component\n// Capture PpuReadResult\n// Update VBlankLedger on $2002 read\n// Handle race_hold detection\n// Update open bus\n// Check debugger", fillcolor=wheat, shape=box3d];
            bus_write [label="busWrite(self, addr, value)\n// Route to component\n// Update open bus\n// Check debugger\n// NOTE: No VBlankLedger tracking", fillcolor=lightcoral, shape=box3d];
            bus_read16 [label="busRead16(self, addr) u16\n// Little-endian read", fillcolor=wheat];
            bus_read16bug [label="busRead16Bug(self, addr) u16\n// JMP indirect page wrap", fillcolor=wheat];
            bus_peek [label="peekMemory(self, addr) u8\n// No side effects\n// Debugger-safe", fillcolor=lightgreen];
        }

        subgraph cluster_apply_ppu_result {
            label="PPU Result Processing";
            style=dashed;

            apply_ppu_result [label="applyPpuCycleResult(result)\n// Process PPU events\n// VBLANK COORDINATION:\n// if (result.nmi_signal)\n//     vblank_ledger.last_set_cycle = clock.ppu_cycles\n// if (result.vblank_clear)\n//     vblank_ledger.last_clear_cycle = clock.ppu_cycles\n//     vblank_ledger.race_hold = false\n// Direct field assignment (no methods)", fillcolor=lightcoral, shape=box3d];
        }
    }

    // ========== MASTER CLOCK (src/emulation/MasterClock.zig) ==========
    subgraph cluster_master_clock {
        label="MasterClock (src/emulation/MasterClock.zig)\nSingle Source of Timing Truth";
        style=filled;
        fillcolor=yellow;

        clock_state [label="MasterClock:\nppu_cycles: u64         // ONLY timing counter\nspeed_multiplier: f64   // External speed control\n\nHardware Model:\n21.477272 MHz master oscillator\nPPU: ÷4 = 5.369318 MHz\nCPU: ÷12 = 1.789773 MHz\nRatio: 3 PPU cycles per CPU cycle", fillcolor=yellow, shape=record];

        clock_advance [label="advance(self, cycles) void\n// ONLY function that mutates time\n// Called by tick()", fillcolor=yellow, shape=box3d, penwidth=2];

        clock_derive [label="Derived Timing (Pure Functions):\nscanline() u16        // (cycles / 341) % 262\ndot() u16             // cycles % 341\nframe() u64           // cycles / 89342\ncpuCycles() u64       // cycles / 3\nisCpuTick() bool      // cycles % 3 == 0\nisApuTick() bool      // same as CPU\nisOddFrame() bool     // frame() & 1\nframePosition() u32   // cycles % 89342\nscanlineAndDot()      // Both at once", fillcolor=lightyellow, shape=record];

        clock_control [label="Speed Control:\nsetSpeed(multiplier)\ngetSpeed() f64\nreset() void", fillcolor=wheat];
    }

    // ========== TIMING STEP (src/emulation/state/Timing.zig) ==========
    subgraph cluster_timing_step {
        label="Timing Coordination (src/emulation/state/Timing.zig)";
        style=filled;
        fillcolor=lightyellow;

        timing_step [label="TimingStep struct:\lscanline: u16       // PRE-advance position\ldot: u16            // PRE-advance position\lcpu_tick: bool      // POST-advance (after clock.advance())\lapu_tick: bool      // POST-advance (same as cpu_tick)\lskip_slot: bool     // Odd frame skip occurred\l\lReturned by nextTimingStep()\l\lCRITICAL TIMING:\lPRE-advance coordinates allow components to see\lwhere they ARE before advancing to next cycle.\lPOST-advance bools tell components if CPU/APU\nshould tick AFTER PPU processes current cycle.\l", fillcolor=lightyellow, shape=box];

        next_timing_step [label="nextTimingStep(self) TimingStep\n// Compute timing step\n// Advance clock by 1 (or 2 if skip)\n// Return metadata for components\n// SIDE EFFECTS:\n// - Advances clock\n// - May skip odd frame dot", fillcolor=yellow, shape=box3d];

        timing_helpers [label="TimingHelpers:\nshouldSkipOddFrame(odd, rendering, sl, dot) bool\n// Returns true at scanline 261 dot 340\n// if odd frame + rendering enabled", fillcolor=wheat];
    }

    // ========== CYCLE RESULTS (src/emulation/state/CycleResults.zig) ==========
    subgraph cluster_cycle_results {
        label="Component Cycle Results";
        style=filled;
        fillcolor=lightgray;

        ppu_result [label="PpuCycleResult:\nrendering_enabled: bool\nframe_complete: bool\nnmi_signal: bool     // VBlank set @ 241.1\nvblank_clear: bool   // VBlank clear @ 261.1\na12_rising: bool     // For MMC3 IRQ", fillcolor=lightcoral, shape=record];

        cpu_result [label="CpuCycleResult:\nmapper_irq: bool     // IRQ from cartridge", fillcolor=lightgreen, shape=record];

        apu_result [label="ApuCycleResult:\nframe_irq: bool      // Frame counter IRQ\ndmc_irq: bool        // DMC sample IRQ", fillcolor=lightyellow, shape=record];
    }

    // ========== PPU READ RESULT (src/ppu/logic/registers.zig) ==========
    subgraph cluster_ppu_read_result {
        label="PPU Read Result (src/ppu/logic/registers.zig)\nPure Function Side-Effect Signaling";
        style=filled;
        fillcolor=lightcyan;

        ppu_read_result_struct [label="PpuReadResult struct:\lvalue: u8           // Register value to return\lread_2002: bool     // True if $2002 was read\l\lPurpose:\lSignal $2002 read to EmulationState without mutating VBlankLedger\lEnables pure functional register read logic in PPU\lEmulationState updates VBlankLedger based on this flag\l", fillcolor=lightcyan, shape=box];

        build_status_byte [label="buildStatusByte(\n  sprite_overflow: bool,\n  sprite_0_hit: bool,\n  vblank_flag: bool,\n  data_bus_latch: u8\n) u8\n// PURE HELPER: Construct $2002 value\n// Combines sprite flags + VBlank flag + open bus\n// VBlank flag computed from VBlankLedger timestamps", fillcolor=palegreen, shape=box3d];
    }

    // ========== BUS STATE (src/emulation/state/BusState.zig) ==========
    subgraph cluster_bus_state {
        label="BusState (src/emulation/state/BusState.zig)\nMemory Bus Data";
        style=filled;
        fillcolor=wheat;

        bus_state [label="BusState:\nram: [2048]u8       // 2KB, mirrored $0000-$1FFF\nopen_bus: u8        // Last bus value\ntest_ram: ?[]u8     // For tests (no cartridge)", fillcolor=wheat, shape=record];
    }

    // ========== VBLANK LEDGER (src/emulation/VBlankLedger.zig) ==========
    subgraph cluster_vblank_ledger {
        label="VBlankLedger (src/emulation/VBlankLedger.zig)\nPure Data Struct - Phase 4 Refactor";
        style=filled;
        fillcolor=lightcoral;

        vblank_ledger_state [label="VBlankLedger (PURE DATA STRUCT):\l\lTimestamp Fields (u64 - PPU cycles):\llast_set_cycle = 0       // Scanline 241.1\llast_clear_cycle = 0     // Scanline 261.1 (timing)\llast_read_cycle = 0      // $2002 read time\llast_nmi_ack_cycle = 0   // CPU interrupt ack\l\lRace Condition Fix:\lrace_hold: bool = false  // Read on exact set cycle\l                          // Keeps flag visible\l                          // Cleared at 261.1\l\lONLY METHOD:\lreset(self) void         // Reset all fields\l\lArchitecture:\l• EmulationState ONLY mutates (single source of truth)\l• PPU reads by value (pure function)\l• Computes VBlank flag from timestamp comparison\l• No hidden side effects or complex methods\l", fillcolor=lightcoral, shape=box];

        vblank_computation_note [label="VBlank Flag Computation (Pure Function):\l\lIn ppu/logic/registers.zig readRegister():\l\l  const vblank_active = \l    (ledger.last_set_cycle > ledger.last_clear_cycle) and\l    (ledger.race_hold or \l     (ledger.last_set_cycle > ledger.last_read_cycle))\l\lLogic:\l1. VBlank active if set more recently than cleared\l2. AND (race_hold OR set more recently than read)\l3. race_hold keeps flag visible after race condition\l4. Computed on-demand, not stored\l", fillcolor=lightyellow, shape=note];
    }

    // ========== OAM DMA (src/emulation/state/peripherals/OamDma.zig) ==========
    subgraph cluster_oam_dma {
        label="OamDma (src/emulation/state/peripherals/OamDma.zig)\n256-Byte Sprite DMA";
        style=filled;
        fillcolor=lightyellow;

        oam_dma_state [label="OamDma:\nactive: bool\npage: u8              // $xx00 source address\nbyte_index: u8        // 0-255 progress\ntransfer_buffer: u8   // Current byte\ncycle_phase: DmaCyclePhase\n\nStalls CPU for 513/514 cycles", fillcolor=lightyellow, shape=record];

        oam_dma_trigger [label="trigger(page)\n// Write to $4014\n// Starts DMA", fillcolor=wheat];
        oam_dma_tick [label="tick(state) void\n// Called every CPU cycle\n// Progresses state machine", fillcolor=yellow];
        oam_dma_reset [label="reset()\n// Clear state", fillcolor=lightblue];
    }

    // ========== DMC DMA (src/emulation/state/peripherals/DmcDma.zig) ==========
    subgraph cluster_dmc_dma {
        label="DmcDma (src/emulation/state/peripherals/DmcDma.zig)\nDPCM Sample Fetch";
        style=filled;
        fillcolor=lightcoral;

        dmc_dma_state [label="DmcDma:\nactive: bool\naddress: u16          // Sample address\ncycle_phase: DmaDmcPhase\n\nStalls CPU for 4 cycles per byte\nTriggered by APU when buffer empty", fillcolor=lightcoral, shape=record];

        dmc_dma_trigger [label="triggerFetch(address)\n// Called by APU\n// Starts DMA", fillcolor=wheat];
        dmc_dma_tick [label="tick(state) void\n// Called every CPU cycle\n// Progresses state machine", fillcolor=yellow];
        dmc_dma_reset [label="reset()\n// Clear state", fillcolor=lightblue];
    }

    // ========== CONTROLLER (src/emulation/state/peripherals/ControllerState.zig) ==========
    subgraph cluster_controller {
        label="ControllerState (src/emulation/state/peripherals/ControllerState.zig)\nNES Controller Interface";
        style=filled;
        fillcolor=lightgreen;

        controller_state [label="ControllerState:\nshift_register: u8    // 8 buttons (A,B,Sel,St,U,D,L,R)\nstrobe: bool          // Latch mode\nbutton_state: u8      // Current button state\n\nReads from mailbox on strobe", fillcolor=lightgreen, shape=record];

        controller_write [label="write(value)\n// $4016: Strobe bit\n// Latch buttons on 1→0", fillcolor=wheat];
        controller_read [label="read() u8\n// $4016: Read next bit\n// Shift out buttons", fillcolor=lightgreen];
        controller_update [label="updateButtons(buttons)\n// Update from mailbox", fillcolor=wheat];
    }

    // ========== CPU EXECUTION (src/emulation/cpu/execution.zig) ==========
    subgraph cluster_cpu_execution {
        label="CPU Execution (src/emulation/cpu/execution.zig)\nCycle-Accurate State Machine";
        style=filled;
        fillcolor=lightgreen;

        cpu_step_cycle [label="stepCycle(state) CpuCycleResult\n// Called every CPU tick\n// SIDE EFFECTS:\n// - Tick DMA state machines\n// - Execute CPU cycle\n// - Poll mapper IRQ\n// Returns: mapper_irq flag", fillcolor=lightgreen, shape=box3d];

        cpu_execute_cycle [label="executeCycle(state) void\n// Delegates to Logic.tick()\n// Implements 4-state machine", fillcolor=lightgreen];
    }

    // ========== PPU RUNTIME (src/ppu/Logic.zig) ==========
    subgraph cluster_ppu_runtime {
        label="PPU Runtime (src/ppu/Logic.zig)\nPPU Orchestration";
        style=filled;
        fillcolor=lightcoral;

        ppu_tick [label="tick(ppu, scanline, dot, cart, fb) PpuFlags\n// Called every PPU cycle\n// Explicit timing coordinates\n// SIDE EFFECTS:\n// - Update VRAM/OAM/palette\n// - Render pixels to framebuffer\n// - Return event flags (no mutations)\n// Returns: rendering_enabled, frame_complete, nmi_signal, vblank_clear, a12_rising", fillcolor=lightcoral, shape=box3d];

        ppu_read_register [label="readRegister(\n  ppu: *PpuState,\n  cart: ?*AnyCartridge,\n  address: u16,\n  vblank_ledger: VBlankLedger\n) PpuReadResult\n// PURE FUNCTION (regarding VBlankLedger)\n// Takes ledger by value (read-only)\n// Computes VBlank flag from timestamps\n// Returns PpuReadResult with value + read_2002 flag\n// EmulationState updates ledger based on flag", fillcolor=lightcyan, shape=box3d];
    }

    // ========== DMA LOGIC (src/emulation/dma/logic.zig) ==========
    subgraph cluster_dma_logic {
        label="DMA Logic (src/emulation/dma/logic.zig)\nDMA State Machine Drivers";
        style=filled;
        fillcolor=lightyellow;

        dma_tick_oam [label="tickOamDma(state) void\n// Called every CPU cycle\n// Progresses OAM DMA state machine\n// SIDE EFFECTS:\n// - Read from source address\n// - Write to PPU OAM\n// - Stall CPU", fillcolor=yellow, shape=box3d];

        dma_tick_dmc [label="tickDmcDma(state) void\n// Called every CPU cycle\n// Progresses DMC DMA state machine\n// SIDE EFFECTS:\n// - Read from sample address\n// - Write to APU sample buffer\n// - Stall CPU", fillcolor=yellow, shape=box3d];
    }

    // ========== DEBUG INTEGRATION (src/emulation/debug/integration.zig) ==========
    subgraph cluster_debug_integration {
        label="Debug Integration (src/emulation/debug/integration.zig)\nDebugger RT-Safe Interface";
        style=filled;
        fillcolor=lightblue;

        debug_should_halt [label="shouldHalt(state) bool\n// Check if debugger paused\n// Pure: No side effects", fillcolor=lightgreen];

        debug_is_paused [label="isPaused(state) bool\n// Public query for threads", fillcolor=lightgreen];

        debug_check_memory [label="checkMemoryAccess(state, addr, value, is_write)\n// Called on all bus ops\n// Check breakpoints/watchpoints\n// SIDE EFFECTS:\n// - Set debug_break_occurred\n// - Pause execution", fillcolor=lightcoral];
    }

    // ========== BUS INSPECTION (src/emulation/bus/inspection.zig) ==========
    subgraph cluster_bus_inspection {
        label="Bus Inspection (src/emulation/bus/inspection.zig)\nDebugger-Safe Memory Reads";
        style=filled;
        fillcolor=lightgreen;

        inspect_peek [label="peekMemory(state, addr) u8\n// Read without side effects\n// Does NOT update open_bus\n// Safe for debugger", fillcolor=lightgreen];
    }

    // ========== HELPERS (src/emulation/helpers.zig) ==========
    subgraph cluster_helpers {
        label="Emulation Helpers (src/emulation/helpers.zig)\nConvenience Wrappers";
        style=filled;
        fillcolor=lightgray;

        helper_frame [label="emulateFrame(state) u64\n// Run until frame_complete\n// Returns: PPU cycles elapsed", fillcolor=lightgray];

        helper_cpu_cycles [label="emulateCpuCycles(state, n) u64\n// Run N CPU cycles\n// Returns: PPU cycles elapsed", fillcolor=lightgray];

        helper_tick_cpu_clock [label="tickCpuWithClock(state)\n// Advance clock by 3\n// Tick CPU\n// For CPU-only tests", fillcolor=lightgray];
    }

    // ========== MAIN DATA FLOW ==========

    // EmulationState contains all components
    owned_state -> clock_state [label="contains", style=dotted];
    owned_state -> bus_state [label="contains", style=dotted];
    owned_state -> vblank_ledger_state [label="contains", style=dotted];
    owned_state -> oam_dma_state [label="contains", style=dotted];
    owned_state -> dmc_dma_state [label="contains", style=dotted];
    owned_state -> controller_state [label="contains", style=dotted];

    // Main tick flow
    emu_tick -> next_timing_step [label="1. Compute timing", color=blue, penwidth=2];
    next_timing_step -> clock_advance [label="advances", color=blue, penwidth=2];
    next_timing_step -> timing_helpers [label="uses", style=dashed];
    next_timing_step -> timing_step [label="returns", color=blue];

    emu_tick -> ppu_tick [label="2. Tick PPU (every cycle)", color=red, penwidth=2];
    ppu_tick -> ppu_result [label="returns", color=red];

    emu_tick -> cpu_step_cycle [label="3. Tick CPU (if cpu_tick)", color=green, penwidth=2];
    cpu_step_cycle -> dma_tick_oam [label="tick DMA", color=orange];
    cpu_step_cycle -> dma_tick_dmc [label="tick DMC DMA", color=orange];
    cpu_step_cycle -> cpu_execute_cycle [label="execute", color=green];
    cpu_step_cycle -> cpu_result [label="returns", color=green];

    emu_tick -> apu_result [ltail=cluster_emulation_state, label="4. Tick APU (if apu_tick)", color=orange];

    // VBlank ledger coordination (UPDATED - direct assignment)
    ppu_result -> apply_ppu_result [label="events", color=red];
    apply_ppu_result -> vblank_ledger_state [label="direct field assignment:\nlast_set_cycle\nlast_clear_cycle\nrace_hold = false", color=purple, penwidth=2];

    // Bus routing with PpuReadResult pattern
    bus_read -> ppu_read_register [label="$2000-$3FFF reads", color=blue];
    ppu_read_register -> ppu_read_result_struct [label="returns", color=blue];
    ppu_read_result_struct -> vblank_ledger_state [label="if (result.read_2002):\nlast_read_cycle = now\nif race: race_hold = true", color=purple, penwidth=2];

    // buildStatusByte usage
    ppu_read_register -> build_status_byte [label="uses for $2002", style=dashed];
    vblank_ledger_state -> ppu_read_register [label="passed by value\n(read-only)", color=lightblue, style=dashed];

    // Bus routing (no VBlank tracking in writes)
    bus_peek -> inspect_peek [label="delegate", color=green];

    // Debugger checks
    bus_read -> debug_check_memory [label="check watchpoints", style=dashed];
    bus_write -> debug_check_memory [label="check watchpoints", style=dashed];
    emu_tick -> debug_should_halt [label="check pause", style=dashed];

    // DMA triggers
    bus_write -> oam_dma_trigger [label="$4014 write", color=orange];
    apu_result -> dmc_dma_trigger [ltail=cluster_apu_result, label="on sample needed", color=orange];

    // Helper delegation
    emu_helpers -> helper_frame [lhead=cluster_helpers, label="delegates", style=dashed];

    // Clock derivation
    clock_state -> clock_derive [label="contains", style=dotted];
    next_timing_step -> clock_derive [label="query", style=dashed];
    ppu_tick -> clock_derive [label="uses scanline/dot", style=dashed];

    // Legend
    subgraph cluster_legend {
        label="Legend";
        style=filled;
        fillcolor=white;
        rank=sink;

        legend_solid [label="Solid: Direct call/contains", penwidth=2];
        legend_blue [label="Blue: Main tick flow", color=blue, penwidth=2];
        legend_red [label="Red: PPU coordination", color=red, penwidth=2];
        legend_green [label="Green: CPU execution", color=green, penwidth=2];
        legend_orange [label="Orange: DMA/APU coordination", color=orange];
        legend_purple [label="Purple: VBlank coordination (Phase 4)", color=purple, penwidth=2];
        legend_dashed [label="Dashed: Query/lookup", style=dashed];
        legend_dotted [label="Dotted: Containment", style=dotted];
    }

    // Critical timing behaviors
    subgraph cluster_critical_timing {
        label="Critical Timing Behaviors";
        style=filled;
        fillcolor=white;
        rank=sink;

        timing_odd_frame [label="Odd Frame Skip:\n- Occurs at scanline 261 dot 340\n- Only if odd frame + rendering enabled\n- Skips dot 0 of scanline 0\n- nextTimingStep() advances by 2 cycles\n- Manually sets frame_complete flag\n- Result: Odd frames are 89,341 cycles", fillcolor=yellow, shape=note];

        timing_vblank [label="VBlank Timing (Phase 4 Architecture):\n- Set @ scanline 241.1 → vblank_ledger.last_set_cycle = clock.ppu_cycles\n- Clear @ scanline 261.1 → vblank_ledger.last_clear_cycle = clock.ppu_cycles\n- $2002 read → vblank_ledger.last_read_cycle = now\n- Race condition → vblank_ledger.race_hold = true\n- VBlank flag computed on-demand from timestamps\n- PPU readRegister() is PURE (no mutations)\n- EmulationState orchestrates all updates", fillcolor=yellow, shape=note];

        timing_execution_order [label="Same-Cycle Execution Order:\n1. PPU (may trigger NMI via nmi_signal flag)\n2. APU (may trigger IRQ, DMA)\n3. CPU (may read registers)\nOrder matters for correct emulation", fillcolor=yellow, shape=note];

        timing_dma_priority [label="DMA Priority:\n1. OAM DMA (513/514 cycles)\n2. DMC DMA (4 cycles per byte)\nBoth stall CPU during transfer\nAPU DMC triggers DMC DMA", fillcolor=yellow, shape=note];
    }

    // Ownership summary
    subgraph cluster_ownership {
        label="Ownership & Lifetime";
        style=filled;
        fillcolor=white;
        rank=sink;

        own_emulation [label="EmulationState:\nDirect ownership of all components\nStack-allocated (no heap)\nNo pointer wiring (connectComponents eliminated)\nSingle source of truth architecture\nONLY entity that mutates VBlankLedger", fillcolor=lightcyan, shape=note];

        own_clock [label="MasterClock:\nSingle timing counter (ppu_cycles)\nAll other timing derived on demand\nComponents NEVER advance time\nModels single crystal oscillator", fillcolor=yellow, shape=note];

        own_ledger [label="VBlankLedger (Phase 4 Refactor):\nPure data struct (5 fields, 1 method)\nSingle source of VBlank truth\nTimestamp-based determinism\nrace_hold flag for race condition fix\nEmulationState ONLY mutates\nPPU reads by value (pure function)\nNo complex methods or hidden state", fillcolor=lightcoral, shape=note];
    }

    // Side effects summary
    subgraph cluster_side_effects {
        label="Side Effects Summary";
        style=filled;
        fillcolor=white;
        rank=sink;

        side_timing [label="Timing Mutation:\n- ONLY clock.advance() mutates time\n- Called ONLY by nextTimingStep()\n- All other timing is derived (pure functions)\n- Odd frame skip: advance(2) instead of advance(1)", fillcolor=lightyellow, shape=note];

        side_state [label="State Mutation:\n- tick() → stepPpuCycle() → PpuLogic.tick()\n- tick() → stepCpuCycle() → CpuLogic.tick()\n- tick() → stepApuCycle() → ApuLogic.tick*()\n- DMA state machines progress\n- VBlank ledger: direct field assignment", fillcolor=lightyellow, shape=note];

        side_bus [label="Bus I/O:\n- busRead() updates open_bus\n- busWrite() updates open_bus\n- $2002 read → VBlankLedger update (last_read_cycle, race_hold)\n- $4014 write → trigger OAM DMA\n- PPU/APU register side effects\n- NOTE: $2000 writes NO LONGER tracked in VBlankLedger", fillcolor=lightcoral, shape=note];

        side_debugger [label="Debugger:\n- All bus ops check watchpoints\n- tick() checks shouldHalt()\n- No heap allocation in hot path\n- RT-safe by design", fillcolor=lightblue, shape=note];
    }

    // Hardware accuracy notes
    subgraph cluster_hardware_accuracy {
        label="Hardware Accuracy Notes";
        style=filled;
        fillcolor=white;
        rank=sink;

        hw_ratios [label="Clock Ratios:\n21.477272 MHz master oscillator\nPPU: ÷4 = 5.369318 MHz (341 dots × 262 scanlines)\nCPU: ÷12 = 1.789773 MHz (3:1 PPU ratio)\nAPU: Same as CPU\nFrame: 60.0988 Hz (89,342 or 89,341 cycles)", fillcolor=wheat, shape=note];

        hw_memory_map [label="NES Memory Map:\n$0000-$1FFF: RAM (2KB, mirrored 4×)\n$2000-$3FFF: PPU (8 registers, mirrored)\n$4000-$4013: APU channels\n$4014: OAM DMA trigger\n$4015: APU status/control\n$4016-$4017: Controllers + frame counter\n$4020-$FFFF: Cartridge (PRG-ROM/RAM)", fillcolor=wheat, shape=note];

        hw_vblank [label="VBlank Duration:\nStarts: Scanline 241 dot 1\nEnds: Scanline 261 dot 1 (pre-render)\nDuration: 20.33 scanlines = 6933 PPU cycles\nRace Condition: Read on exact set cycle\n  → race_hold keeps flag visible\n  → Cleared at pre-render (261.1)", fillcolor=wheat, shape=note];
    }

    // Phase 4 refactor summary
    subgraph cluster_phase4_refactor {
        label="Phase 4 VBlankLedger Refactor Summary";
        style=filled;
        fillcolor=lightcyan;
        rank=sink;

        refactor_summary [label="Architecture Transition (Oct 15-16, 2025):\n\nBEFORE (Stateful):\n• VBlank flag in PpuStatus\n• readRegister() mutated ledger directly\n• Methods: recordVBlankSet(), recordVBlankClear(), etc.\n• Hidden side effects → race conditions\n\nAFTER (Pure Functional):\n• VBlank flag computed from timestamps\n• readRegister() PURE (no mutations)\n• Returns PpuReadResult to signal side effects\n• EmulationState orchestrates mutations\n• race_hold flag fixes race condition\n\nBenefits:\n• RT-safety (no hidden mutations)\n• Testability (pure functions)\n• Determinism (single source of truth)\n• Race condition prevention", fillcolor=lightcyan, shape=note, penwidth=2];
    }
}
