┌─────────────────────────────────────────────────────────────────────────────────┐
│                     PPU VBlank Lifecycle - Complete Flow                        │
└─────────────────────────────────────────────────────────────────────────────────┘

FRAME TIMELINE (PPU Perspective):
═════════════════════════════════════════════════════════════════════════════════

Scanline 0-239 (Visible)
├─ 240 cycles × 341 dots = 81,840 PPU cycles
└─ Background and sprite rendering

Scanline 240 (Post-render)
└─ 1 scanline × 341 dots = 341 PPU cycles

Scanline 241-260 (VBlank Period)
├─ 20 scanlines × 341 dots = 6,820 PPU cycles
├─ ┌─ Scanline 241, Dot 1 (cycle 82,181)
│  ├─ PPU: nmi_signal = true
│  └─ EmulationState.applyPpuCycleResult()
│     └─ vblank_ledger.last_set_cycle = 82,181
│
├─ [VBlank active period]
│  └─ CPU can read $2002 and see flag = 1
│
└─ Scanline 260, Dot 341 (cycle 88,900)
   └─ [Last cycle of VBlank]

Scanline 261 (Pre-render)
├─ Start: cycle 88,901
├─ ┌─ Scanline 261, Dot 1 (cycle 89,001)
│  ├─ PPU: vblank_clear = true
│  ├─ PPU: sprite_0_hit = false
│  ├─ PPU: sprite_overflow = false
│  └─ EmulationState.applyPpuCycleResult()
│     ├─ vblank_ledger.last_clear_cycle = 89,001
│     └─ vblank_ledger.last_race_cycle = 0 (reset)
│
└─ Scanline 261, Dot 340 (cycle 89,341)
   └─ flags.frame_complete = true


VBlankLedger STATE MACHINE:
═════════════════════════════════════════════════════════════════════════════════

                    POWER ON
                        │
                        ▼
        ┌──────────────────────────┐
        │  Idle (all zeros)        │
        │ last_set_cycle = 0       │
        │ last_clear_cycle = 0     │
        │ last_read_cycle = 0      │
        │ isActive() = false       │
        └──────┬───────────────────┘
               │
               │ Scanline 241, Dot 1
               │ (VBlank SET signal from PPU)
               ▼
        ┌──────────────────────────┐
        │  VBlank Active           │
        │ last_set_cycle = 82181   │
        │ last_clear_cycle = 0     │
        │ last_read_cycle = 0      │
        │ isActive() = true        │
        │ isFlagVisible() = true   │
        └──────┬─────────┬──────────┘
               │         │
               │ (CPU   │ Scanline 261, Dot 1
               │ reads  │ (VBlank CLEAR signal)
               │ $2002) │
               ▼         ▼
        ┌──────────────────────────┐
        │ VBlank Cleared by Timing │
        │ last_clear_cycle = 89001 │
        │ isActive() = false       │
        │ isFlagVisible() = false  │
        └──────────────────────────┘
               │
               │ Scanline 0-240
               │ (rendering resumes)
               ▼
        ┌──────────────────────────┐
        │ Back to Idle             │
        │ Ready for next frame     │
        └──────────────────────────┘


$2002 PPUSTATUS READ SEQUENCE:
═════════════════════════════════════════════════════════════════════════════════

Scenario 1: Normal Read (not at race point)
────────────────────────────────────────────

CPU @ Cycle 1000:
    │
    ├─ BEFORE: last_read_cycle = 0 (no prior reads)
    │
    ├─ Call busRead(0x2002)
    │  │
    │  ├─ Race detection: now(1000) != last_set_cycle(82181)
    │  │  └─ No race
    │  │
    │  ├─ Call PpuLogic.readRegister()
    │  │  │
    │  │  ├─ Query: vblank_ledger.isFlagVisible()
    │  │  │  └─ isActive() = true (82181 > 0)
    │  │  │  └─ last_read_cycle(0) < last_set_cycle(82181)
    │  │  │  └─ Returns: true
    │  │  │
    │  │  ├─ Build status byte with bit7 = 1
    │  │  ├─ Set result.read_2002 = true
    │  │  └─ Return value with VBlank flag set
    │  │
    │  └─ busRead() receives PpuReadResult
    │     │
    │     ├─ ppu_read_result.read_2002 = true
    │     │
    │     └─ Update: last_read_cycle = 1000
    │
    ├─ AFTER: last_read_cycle = 1000
    │
    └─ Return status byte with bit7 = 1 to CPU


Scenario 2: Race Condition (read at same cycle as set)
───────────────────────────────────────────────────────

PPU @ Scanline 241, Dot 1 (cycle 82181):
    │
    └─ nmi_signal = true
       │
       └─ ApplyPpuCycleResult()
          └─ last_set_cycle = 82181

CPU @ Cycle 27394 (corresponds to PPU cycle 82182, same CPU tick)
    │
    ├─ Instruction reads $2002 (but cycles aren't exactly aligned)
    │
    └─ ASSUMPTION: Read occurs at cycle 82181 (same as set)
       │
       ├─ BEFORE: last_read_cycle = 0
       │
       ├─ Call busRead(0x2002)
       │  │
       │  ├─ Race detection: now(82181) == last_set_cycle(82181)
       │  │  ├─ last_set > last_clear (82181 > 0)? YES
       │  │  └─ RACE DETECTED!
       │  │  └─ Set: last_race_cycle = 82181
       │  │
       │  ├─ Call PpuLogic.readRegister() [gets ledger by value]
       │  │  │
       │  │  ├─ Query: vblank_ledger.isFlagVisible()
       │  │  │  └─ Note: ledger is from BEFORE race update
       │  │  │  └─ isActive() = true
       │  │  │  └─ last_read_cycle(0) < last_set_cycle(82181)
       │  │  │  └─ Returns: true (flag still visible!)
       │  │  │
       │  │  └─ Build status byte with bit7 = 1
       │  │
       │  └─ busRead() receives result
       │     │
       │     └─ Update: last_read_cycle = 82181
       │
       ├─ AFTER: last_read_cycle = 82181
       │        last_race_cycle = 82181
       │        hasRaceSuppression() = true
       │
       └─ Return status byte with bit7 = 1 (but NMI will be suppressed)

       NEXT $2002 READ:
       └─ isFlagVisible()
          ├─ isActive() = true
          ├─ last_read_cycle(82181) >= last_set_cycle(82181)
          └─ Returns: false (flag cleared!)


NMI LINE MANAGEMENT:
═════════════════════════════════════════════════════════════════════════════════

Every CPU Cycle:
    │
    └─ CpuExecution.stepCycle()
       │
       ├─ Query ledger
       │  │
       │  ├─ vblank_flag_visible = ledger.isFlagVisible()
       │  ├─ nmi_enabled = ppu.ctrl.nmi_enable
       │  │
       │  └─ nmi_line_should_assert = vblank_flag_visible AND nmi_enabled
       │
       └─ cpu.nmi_line = nmi_line_should_assert


EDGE DETECTION (CPU):
═════════════════════════════════════════════════════════════════════════════════

State:
  cpu.nmi_line: LEVEL signal (follows VBlank flag AND NMI enable)
  cpu.nmi_edge_detected: EDGE signal (latches 0→1 transition)

Each Cycle:
  │
  ├─ Check: (nmi_line == HIGH) AND (nmi_edge_detected == false)
  │
  ├─ If true: nmi_edge_detected = true
  │           pending_interrupt = .nmi
  │           [NMI will execute in next cycles]
  │
  ├─ If false: nmi_edge_detected = nmi_line
  │            [Stays cleared until line goes low again]
  │
  └─ After interrupt completes:
     pending_interrupt = .none
     nmi_edge_detected = false


RACE CONDITION HANDLING (Current Implementation):
═════════════════════════════════════════════════════════════════════════════════

Exact-Cycle Race Detection:
  ├─ Trigger: now == last_set_cycle
  ├─ Action: last_race_cycle = last_set_cycle
  └─ Effect: hasRaceSuppression() returns true

Flag Clearing:
  ├─ Mechanism: isFlagVisible() checks last_read_cycle >= last_set_cycle
  ├─ Result: Flag clears IDENTICALLY for race and normal reads
  └─ Logic: ALL reads clear the flag

NMI Suppression:
  ├─ Trigger: hasRaceSuppression() returns true
  ├─ Effect: NMI generation should skip (currently not fully implemented)
  └─ Note: Flag clearing is independent from suppression

Known Limitation:
  ├─ Detects: Read on same cycle as set
  ├─ Missing: Read one cycle after set (per nesdev.org)
  └─ Note: Both should suppress NMI (only exact-cycle implemented)


MASTER CLOCK CALCULATION:
═════════════════════════════════════════════════════════════════════════════════

Formula: cycle = (scanline * 341) + dot

Examples:
  Scanline 0, Dot 0    → cycle = 0
  Scanline 241, Dot 1  → cycle = (241 * 341) + 1 = 82,182 (off-by-one correction)
                       → Actually 82,181 (0-indexed)
  Scanline 261, Dot 1  → cycle = (261 * 341) + 1 = 89,002 (off-by-one)
                       → Actually 89,001 (0-indexed)
  Scanline 261, Dot 340→ cycle = (261 * 341) + 340 = 89,341


CPU CYCLE MAPPING:
═════════════════════════════════════════════════════════════════════════════════

PPU cycles: 0    1    2    3    4    5    6    7    8    9    10   11   ...
             │    │    │    │    │    │    │    │    │    │    │    │
CPU cycle:   0             1             2             3             4
             │             │             │             │             │
             (tick)        (tick)        (tick)        (tick)

CPU executes at PPU cycles: 0, 3, 6, 9, 12, 15, ...

So VBlank set at PPU cycle 82,181:
  CPU cycle = 82,181 / 3 = 27,393.67
  Affects cycles starting at 27,394


SYNCHRONIZATION ORDER (Per EmulationState.tick()):
═════════════════════════════════════════════════════════════════════════════════

1. nextTimingStep()
   └─ Advance master clock by 1 PPU cycle (+ 1 if odd frame skip)

2. stepPpuCycle(scanline, dot)
   └─ Run PPU at current position
   └─ May return nmi_signal or vblank_clear flags

3. applyPpuCycleResult(ppu_result)
   ├─ If nmi_signal: update ledger.last_set_cycle
   └─ If vblank_clear: update ledger.last_clear_cycle

4. stepApuCycle() [if APU tick]
   └─ Process audio, may generate IRQ

5. stepCpuCycle() [if CPU tick]
   ├─ Check NMI line based on CURRENT ledger state
   ├─ Execute CPU operation
   └─ May read $2002 via busRead()

Result: CPU sees updated ledger immediately after PPU signals

