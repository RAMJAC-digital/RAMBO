# RAMBO Compiler Helpers

Python-based utilities (managed with `uv`) for building companion NES ROMs used by the RAMBO emulator project.

## Quick start

```bash
cd compiler
uv run compiler toolchain            # clone + build patched nesasm
uv run compiler build-accuracycoin   # produces compiler/dist/accuracycoin/AccuracyCoin.nes
uv run compiler analyze-basic        # refresh Microsoft BASIC macro manifest (docs/)
uv run compiler preprocess-basic     # expand BASIC macros → compiler/dist/basic/m6502.preprocessed.asm
uv run compiler preprocess-basic --verify  # same as above, but fails if legacy macros/IFs remain
```

Use `--output` to choose a different destination or `--keep-temp` to inspect the intermediate workspace.
By default the build is checked against the repository's `AccuracyCoin/AccuracyCoin.nes` and will abort if the result
is not bit-identical; pass `--skip-verify` only when intentionally generating a diverging ROM.

## Toolchain details

- **Assembler target:** We build with `nesasm` (v3.1 lineage). The CLI keeps a patched copy under
  `compiler/.toolchain/nesasm` and will rebuild it on demand with `--force`.
- **Patches applied automatically:**
  - Increase the global symbol buffer (`SBOLSZ`) from 32 → 128, matching AccuracyCoin's long label names.
  - Fix two PCX helper bugs so `.incchr` assets work without crashing.
- **Binary location:** `compiler/.toolchain/nesasm/bin/nesasm`. Set this in other scripts if you prefer manual use.

### Memory reference (NES quick sheet)

These offsets are handy when wiring new test ROMs:

| Region | Address range | Purpose |
| --- | --- | --- |
| Internal RAM | `$0000-$07FF` mirrored to `$1FFF` | NES work RAM (2 KiB) |
| PPU I/O | `$2000-$2007` mirrored to `$3FFF` | PPU register interface |
| APU & I/O | `$4000-$4017` | APU, controllers, DMA |
| Cartridge space | `$4020-$FFFF` | Mapper-controlled area (NROM maps PRG here) |
| Vectors | `$FFFA-$FFFF` | NMI, Reset, IRQ vectors |

PPU memory (when assembling graphics assets):

| Region | Address range | Notes |
| --- | --- | --- |
| Pattern tables | `$0000-$1FFF` | CHR ROM/RAM (8 KiB total) |
| Nametables | `$2000-$2FFF` | 4×1 KiB nametables (mirroring mapper-dependent) |
| Palettes | `$3F00-$3F1F` | Background & sprite palettes (32 bytes) |

Keep these in mind when adding new segments or zero page allocations to avoid overlap.

## Microsoft BASIC status

The original Microsoft BASIC (`BASIC-M6502/m6502.asm`) relies on DEC-style macro facilities that are not yet supported by the current toolchain. The command

```bash
uv run compiler build-basic
```

will exit with a TODO notice until a compatible assembler translation layer is completed. Planned work includes:

1. Translating the macro/conditional syntax to a modern 6502 assembler (e.g. 64tass or ca65).
2. Designing NES-specific I/O stubs (PPU, controllers, RAM mapping) so the interpreter can execute inside RAMBO.

Contributions toward this translation are welcome—see inline comments in `compiler/src/compiler/cli.py` for extension points. The detailed port plan lives in
[`docs/microsoft-basic-port-plan.md`](docs/microsoft-basic-port-plan.md).

- Current artefacts:
  - Macro manifest generated by `uv run compiler analyze-basic` → `docs/microsoft-basic-macro-manifest.json`.
  - Macro-expansion pass emits NESASM-friendly assembly via `uv run compiler preprocess-basic` (use `--verify` for a strict gate); see `docs/macro-expansion-design.md` for the transformation rules and known gaps.
  - Configuration defaults for the NES target live in `docs/basic-configurations.md`.

### Remaining work

- **Memory/IO integration:** finalise the NES memory map, zero-page layout, and add a PPU text renderer so BASIC I/O can target the NES display.
- **CHR assets:** decide on a character set (AccuracyCoin tiles vs. custom) and package it alongside the ROM build.
- **`build-basic` command:** once the preprocessed output assembles cleanly, wire `compiler build-basic` to run the pipeline + nesasm and emit `compiler/dist/basic/basic.nes`.
- **Runtime verification:** add automated tests that assemble the ROM, boot it inside RAMBO, and smoke-test console I/O to ensure regressions are caught.

## Development notes

- `uv` keeps dependencies isolated in `.venv`; commit hooks ignore this directory by default.
- Generated ROMs are written to `compiler/dist/` (or your chosen `--output` path) so the source trees remain untouched.
- All subprocess invocations inherit the current environment; set `MAKEFLAGS`, etc., if you need custom build options.

## Target catalog

### AccuracyCoin

- Mapper: NROM (mapper 0)
- PRG: 2 × 16 KiB banks → `$8000-$FFFF`
- CHR: 1 × 8 KiB bank → pattern tables `$0000-$1FFF`
- Entry point: reset vector at `$FFFC` (auto-generated by nesasm header)
- Build command: `uv run compiler build-accuracycoin`
- Output: `compiler/dist/accuracycoin/AccuracyCoin.nes`

### Microsoft BASIC (in progress)

- Source: `BASIC-M6502/m6502.asm`
- Macros: Uses `DEFINE`/`XWD`/conditional assembly from DEC tooling
- Next steps: translate macros, provide NES I/O shims (PPU/keyboard-to-controller), add mapper header.

Add future targets by copying the `build_accuracycoin` pattern in `compiler/src/compiler/cli.py` and updating this catalog.
